# 1st
- 前提: Arai60は一度一周しているが、その時の状態をなるべく思い出しながら進める
- 問題: [141. Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/description/)
- コメント集: [141. Linked List Cycle](https://docs.google.com/document/d/11HV35ADPo9QxJOpJQ24FcZvtvioli770WWdZZDaLOfg/edit?tab=t.0)
- 非情報系出身のため、最初は問題の意味も意図もわからなかった
  - [Detect Loop or Cycle in Linked List](https://www.geeksforgeeks.org/dsa/detect-loop-in-a-linked-list/) や
  - 応用情報、基本情報の参考図書を参照しながらそもそも `LinkedList` ってなんだっけ？を再度学習した
  - メモリ管理における、可変区間方式で使われていると学習 [参考](https://chatgpt.com/c/6899bc08-ef88-8321-b3f1-05a247b37de5)
  - また、フロイドのカメとウサギのアルゴリズムがあるらしいというのを学習した
  - もちろん、`LinkedList` がなんなのか？を理解した後に問題を見ても、カメとウサギのアルゴリズムなんて一切思いつかなかった
- その上で、コメント集を読み出題意図を理解してから解いた
- もちろん、set の解法は見ていない

### フロイドのカメとうさぎ
- 時間計算量: O(N)
- 空間計算量: O(1)
- 回答時間: 5分(もう知っているので)
```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        // 早期 return でサイクルを確実に持たないものを排除
        if (head == null || head.next == null) return false;

        ListNode slow = head;
        ListNode fast = head;
        
        // nullPointerException を回避
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;

            if (slow == fast) return true;
        }

        return false;
    }
}
```

### Set を使った解法
- 方針
  - `currentNode` 変数を使って `ListNode` のつながりをずっと辿っていき、都度Setに保存して、もし同じものをチェックしたらサイクルがあると判断する方針
  - ListNode の数は最大 10^5 なので、線形走査であれば今回の問題であれば AC するだろう
- 時間計算量: O(N) --> `ListNode` 自体を走査するのに O(N), `set.contains` はハッシュ法を用いているので基本的に O(1) 
- 空間計算量: O(N) --> 走査するので N 個の `ListNode` を set に保存することになるから
- 回答時間: 10分
  - 実行してから `set.add` と `set.contains` 処理の順番を間違えて修正に3分くらいかかった
- 調べたこと
  - [HashSet のコンストラクタ詳細](https://docs.oracle.com/javase/jp/8/docs/api/java/util/HashSet.html#HashSet--)
    - 初期容量(16)、負荷計数(0.75)とは何なのか？
    - 初期容量16 は Set のデフォルト容量 --> 指定してもいいが、今回は ListNode を最後まで辿る必要がある。10^5 が今回の ListNode の上限だがこの場合はどうするのが正しいのかわからない
```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) return false;
        Set<ListNode> set = new HashSet<>();
        ListNode currentNode = head;
        while (currentNode != null) {
            if (set.contains(currentNode)) {
                return true;
            }
            set.add(currentNode);
            currentNode = currentNode.next;
        }
        return false;
    }
}
```