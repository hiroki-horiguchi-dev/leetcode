### 1st
- [問題](https://leetcode.com/problems/linked-list-cycle-ii/)
- [コメント](https://docs.google.com/document/d/11HV35ADPo9QxJOpJQ24FcZvtvioli770WWdZZDaLOfg/edit?tab=t.0#heading=h.jfs03xpyyrfl)
  - 今回は特に参考にしたものはない
  - 書いてある内容は多分フロイドのアルゴリズムの発展系
  - 141と同様に実装したあと、slowポインターだけ head に戻す
  - 次にslow, fast ポインターともに一歩ずつ進ませて合致したところが循環の開始ノードである、というやつだったと記憶している
- 方針
  - 開始ノード判定のため、Set につめる
  - 同じ ListNode が存在した場合、そのノードが循環の開始ノードである
- 計算量
  - 時間計算量: リストの長さを N とすると、O(N)
  - 空間計算量: リストの長さを N とすると、最悪Setに全量詰めることになるので、O(N)
- 実装時間
  - 10分
```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode node = head;
        Set<ListNode> set = new HashSet<ListNode>();
        while (node != null) {
            if (set.contains(node)) {
                return node;
            }
            set.add(node);
            node = node.next;
        }
        return null;
    }
}
```

### 2nd (レビュー取り込み)
- diff
  - 変数名を set --> visited へ変更
  - seen より visited の方が LinkedList を駒が歩いているイメージがつきやすいと思った
  - seen は目を動かさないといけないので疲れるイメージが湧いた
```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode node = head;
        Set<ListNode> visited = new HashSet<ListNode>();
        while (node != null) {
            if (set.contains(node)) {
                return node;
            }
            set.add(node);
            node = node.next;
        }
        return null;
    }
}
```

- フロイドのカメとウサギの発展系
```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if (head == null || head.next == null) {
            return null;
        }

        ListNode slow = head;
        ListNode fast = head;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast) {
                break;
            }
        }

        if (fast == null || fast.next == null) {
            return null;
        }

        ListNode pointer = head;
        ListNode meetingNode = fast;
        while (pointer != meetingNode) {
            pointer = pointer.next;
            meetingNode = meetingNode.next;
        }
        return pointer;
    }
}
```

- メソッドを分離して可読性の向上を試みた
```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode meetingNode = getMeetingNode(head);
        if (meetingNode == null) {
            return null;
        }
        ListNode pointer = head;
        while(pointer != meetingNode) {
            pointer = pointer.next;
            meetingNode = meetingNode.next;
        }
        return pointer;
    }

    private ListNode getMeetingNode(ListNode head) {
        if (head == null || head.next == null) {
            return null;
        }
        ListNode slow = head;
        ListNode fast = head;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast) {
                break;
            }
        }
        if (fast == null || fast.next == null) {
            return null;
        }
        return fast;
    }
}
```