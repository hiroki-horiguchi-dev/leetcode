# 1st
- 前提: Arai60は一度一周しているが、その時の状態をなるべく思い出しながら進める
  - 回答を覚えるというより、再度解いてみる過程でどういう着眼点が自分の中で出るか？
  - いくつかの解法を思いつくはずで、その中でベストなものを選択できているか？など、自分の思考過程を観察したい
- 問題: [82. Remove Duplicates from Sorted List II](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/description/)
- コメント集: [82. Remove Duplicated from sorted list](https://docs.google.com/document/d/11HV35ADPo9QxJOpJQ24FcZvtvioli770WWdZZDaLOfg/edit?tab=t.0)
  - https://discord.com/channels/1084280443945353267/1233603535862628432/1267493956833247292
    - なるほどなと思った
    - 最初は current, next と命名していて、コメントを読んで checked/checking, previous/current を使うか色々と迷ったが
    - checked/checking は boolean っぽい印象を与えるのでなし
    - previous/current は 、previous が双方向リストを想起させそうなのでやめておきたい
    - 結論、tail/runner を採用した
- 方針
  - tail/runner の2つのポインターを用意する
  - runner は重複要素がある場合、重複がなくなるまでスキップする
  - スキップし終わった、つまり重複要素がないノードでストップし、そこで tail.next を runner に張り替える
  - runner はループの開始時点で次に進み、再度重複要素の検査を開始する
  - ループが終了(末尾に到達)したら、null を貼って終了とする

### 実装
- 時間計算量: O(N)
- 空間計算量: O(1)
- 回答時間: 20分
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        // 仕様上、あり得ない val で dummy を用意する
        ListNode dummy = new ListNode(-1);

        dummy.next = head;
        ListNode tail = dummy;
        ListNode runner = dummy;

        while (runner.next != null) {
            runner = runner.next;
            if (runner.next != null && runner.val == runner.next.val) {
                while (runner.next != null && runner.val == runner.next.val) {
                    runner = runner.next;
                }
            } else {
                tail.next = runner;
                tail = runner;
            }
        }

        // 末尾到達時、null に張り替える
        tail.next = null;

        return dummy.next;
    }
}
```
- 感想
  - 可読性があまり良くないなあと思う。。。。どこを改善するともう少し読みやすくなるか。。
  - 時間をおいて少し考えたい
  - 別解として、一度全て走査し HashMap で重複要素の数をカウント
  - 2つポインターを用意して、再度頭から走査する
  - 探索側のポインターが重複要素を発見したら、そのカウント数分スキップするみたいな処理を考えた
  - 主に空間計算量の観点から、上記の方が良いと考えて実装した