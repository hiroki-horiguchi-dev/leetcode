# 1st
- 前提: Arai60は一度一周しているが、その時の状態をなるべく思い出しながら進める
- 問題: [83. Remove Duplicates from Sorted List](https://leetcode.com/problems/remove-duplicates-from-sorted-list/description/)
- コメント集: [83. remove duplicates from sorted list](https://docs.google.com/document/d/11HV35ADPo9QxJOpJQ24FcZvtvioli770WWdZZDaLOfg/edit?tab=t.0#heading=h.voz9njv1gtqy)
- 方針
  - 複数の duplicate を削除すれば良いと認識した
  - 2つのポインタ(`current, next`)を用意する
  - 最初に current, next ともに head としておき、next を current の次におく
  - current, next の val を比較し、一致するのであれば next.val が current.next と一致しなくなるところまで飛ばす
  - 一致しないところまで飛ばしたところで、current.next を next に繋ぎかえ、current 自身を next にする
- 所感
  - while ループ中の null チェック箇所でどうなるんだっけ？となりがち
  - テストケースをいくつか紙に書き出して、next が null の時は current.next がどう繋がれるんだっけ？を書き出さないと自信が持てない
  - 頭の中だけでサッと理解して書けるようになりたい

### 実装
- 時間計算量: O(N)
- 空間計算量: O(1)
- 回答時間: 15分
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        // レビュワーの仕様理解負担軽減を目的として、あえて書いておく
        if (head == null) {
            return null;
        }

        ListNode current = head;
        ListNode next = head;
        while (next != null && next.next != null) {
            next = next.next;
            if (current.val == next.val) {
                // 重複しなくなるまで next を飛ばす
                while (next != null && current.val == next.val) {
                    next = next.next;
                }
            }
            current.next = next;
            current = next;
        }
        return head;
    }
}
```

### 2nd
- next をループ内に閉じる
- next を forward に変更
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        // レビュワーの仕様理解負担軽減を目的として、あえて書いておく
        if (head == null) {
            return null;
        }

        ListNode current = head;
        while (current != null && current.next != null) {
            ListNode forward = current.next;
            if (current.val == forward.val) {
                // 重複しなくなるまで forward を飛ばす
                while (forward != null && current.val == forward.val) {
                    forward = forward.next;
                }
            }
            current.next = forward;
            current = forward;
        }
        return head;
    }
}
```